# USING NEXT WITH REACT

Here we'll be building a next app from scratch. That's quite simple:
first of all, create a `package.json` in your root folder:
```json
{}
```
initiate with these brackets.

after that, you can install react and next features:
```cmd
npm install react@latest react-dom@latest next@latest
```
a `node_modules` folder and a `package-lock.json` will be created with deatiled information about each package you have installed and your `package.json` now will refeer your packages:
```json
{
  "dependencies": {
    "next": "^15.4.5",
    "react": "^19.1.1",
    "react-dom": "^19.1.1"
  }
}
```

after that, you can use next file-system routing, wich means that instead of using code to define rotes, we'll use folders to automatically do that. Simply create an `app` folder, and then display your home at a document named `page.jsx` in order to be the main page of your application.
Also add `export default` to your `<HomePage>` component to help next distinguish wich component to render as the main component of the page.

```jsx
import { useState } from "react";

export default function HomePage() {
  const books = ["Pragmatic programmer", "Grokking Algorithms", "Clean Code"];

  const [likes, setLikes] = useState(0);
  const incrementLikes = () => setLikes(likes + 1);
  return (
    <div>
        <HeaderComponent title="Favorite programming books"/>
        <ul>
            {books.map((title, index) => ( 
                <li key={index}> {title} </li>
            ))}
        </ul>
        <button onClick={incrementLikes}>Like {likes}</button>
    </div>
  );
}

function HeaderComponent({ title }) {
  return (
      <h1>{title ? title : "Default title"}</h1>
  );
}
```
now you can add `next dev` to your `package.json` scripts:
```json
{
  "scripts": {
    "dev": "next dev"
  },
  "dependencies": {
    "next": "^15.4.5",
    "react": "^19.1.1",
    "react-dom": "^19.1.1"
  }
}
```
with that it's possible to run `npm run dev` to run the application.

After run, a new file `layout.js` should be displayed at `app` folder:
```js
export const metadata = {
  title: 'Next.js',
  description: 'Generated by Next.js',
}

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body>{children}</body>
    </html>
  )
}
```
This is the main layout of your application. You can use it to add UI elements that are shared across all pages (e.g. navigation, footer, etc).

## SERVER AND CLIENT ENVIRONMENTS

- The client refers to the browser on a userâ€™s device that sends a request to a server for your application code. It then turns the response it receives from the server into an interface the user can interact with.
- The server refers to the computer in a data center that stores your application code, receives requests from a client, does some computation, and sends back an appropriate response.

Each environment has its own set of capabilities and constraints. For example, by moving rendering and data fetching to the server, you can reduce the amount of code sent to the client, which can improve your application's performance. But, as you learned earlier, to make your UI interactive, you need to update the DOM on the client.

Therefore, the code you write for the server and the client is not always the same. Certain operations (e.g. data fetching or managing user state) are better suited for one environment over the other.

### NETWORK BOUNDARY 
The Network Boundary is a conceptual line that separates the different environments.

In React, you choose where to place the network boundary in your component tree. For example, you can fetch data and render a user's posts on the server (using Server Components), then render the interactive LikeButton for each post on the client (using Client Components).

Similarly, you can create a NavBehind the scenes, the components are split into two module graphs. The server module graph (or tree) contains all the Server Components that are rendered on the server, and the client module graph (or tree) contains all Client Components.

After Server Components are rendered, a special data format called the React Server Component Payload (RSC) is sent to the client. The RSC payload contains:

- The rendered result of Server Components.
- Placeholders (or holes) for where Client Components should be rendered and references to their JavaScript files.

React uses this information to consolidate the Server and Client Components and update the DOM on the client. component that is rendered on the server and shared across pages, but if you want to show an active state for links, you can render the list of Links on the client.

### USING CLIENT COMPONENTS

React `UseState` feature, has client-side only usage, with this default server-side pages couldn't use this feature. We can use a separate client-side component for this feature and maintain server-side usage for fetching data and etc.

```jsx
'use client';
import { useState } from 'react';

export default function LikeButton() {
    const [likes, setLikes] = useState(0);
    const incrementLikes = () => setLikes(likes + 1);
    
    return (
        <button onClick={incrementLikes}>
        Like {likes}
        </button>
    );
}
```
```jsx
import { useState } from "react";
import LikeButton from "./like-button";

export default function HomePage() {
  const books = ["Pragmatic programmer", "Grokking Algorithms", "Clean Code"];
  return (
    <div>
        <HeaderComponent title="Favorite programming books"/>
        <ul>
            {books.map((title, index) => ( 
                <li key={index}> {title} </li>
            ))}
        </ul>
        <LikeButton />
    </div>
  );
}

function HeaderComponent({ title }) {
  return (
      <h1>{title ? title : "Default title"}</h1>
  );
}
```